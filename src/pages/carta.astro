---
// @ts-nocheck
/**
 * CARTA.ASTRO - P√°gina de la carta
 * ================================================================
 * 
 * Esta p√°gina genera din√°micamente el men√∫ a partir 
 * de un archivo JSON, organizando las categor√≠as en secciones 
 * navegables con scroll suave y navegaci√≥n sticky.
 * 
 * Funcionalidades principales:
 * - Navegaci√≥n sticky con chips scrolleables horizontalmente
 * - Scroll suave entre secciones con offset din√°mico
 * - Scrollspy que activa autom√°ticamente la pesta√±a correspondiente
 * - Soporte completo para precios simples y m√∫ltiples
 * - Sistema de iconos y badges para items especiales
 * - Responsive y accesible
 * 
 * @author Beatriz Garc√≠a
 * @version 1.0.0
 * @since 2025
 */

import BaseLayout from '@/layouts/BaseLayout.astro';
import rawMenu from '@/data/menu.json';

/**
 * CONFIGURACI√ìN DE ICONOS
 * ================================================================
 * Mapeo de claves de iconos a rutas de archivos.
 * Los iconos deben estar en /public/icons/ y ser PNG o SVG.
 */
const ICONS: Record<string, string> = {
  bocata: '/icons/bocata.png',
  campero: '/icons/campero.png',
  ensalada: '/icons/ensalada.png',
  burger: '/icons/hamburguesa.png',
  kebab: '/icons/kebab.png',
  lata: '/icons/lata.png',
  new: '/icons/new.png',
  pan: '/icons/pan.png',
  patatas: '/icons/patatas.png',
  picante: '/icons/picante.png',
  pollo: '/icons/pollo-asado.png',
  refrescos: '/icons/refrescos.png',
  salsa: '/icons/salsa.png',
  chef: '/icons/sombrero-de-chef.png',
};

/**
 * UTILIDAD: Generador de slugs
 * ================================================================
 * Convierte texto con acentos, espacios y caracteres especiales
 * en un slug v√°lido para URLs y IDs de HTML.
 * 
 * @param s - String a convertir
 * @returns String limpio para usar como ID/slug
 * 
 * @example
 * slugify('Nuestros camperos') // 'nuestros-camperos'
 * slugify('Ensaladas de la huerta') // 'ensaladas-de-la-huerta'
 */
function slugify(s: string): string {
  return String(s)
    .trim()
    .normalize('NFD').replace(/[\u0300-\u036f]/g, '') // Quita acentos
    .replace(/[^a-zA-Z0-9]+/g, '-')                   // No alfanum√©ricos ‚Üí guion
    .replace(/^-+|-+$/g, '')                          // Limpia bordes
    .toLowerCase();
}

/**
 * ORDEN DE CATEGOR√çAS
 * ================================================================
 * Define el orden deseado de aparici√≥n de las categor√≠as.
 * Si una categor√≠a existe en menu.json pero no est√° aqu√≠, se omite.
 */
const ORDER = [
  'Nuestro fuerte',
  'Para compartir', 
  'Ensaladas de la huerta',
  'Entrepanes',
  'Nuestros camperos',
  'Bebidas',
] as const;

/**
 * TIPOS DE DATOS
 * ================================================================
 */

/** Estructura de un item individual del men√∫ */
type Item = {
  /** Nombre del producto */
  name: string;
  /** Precio: string simple u objeto con m√∫ltiples opciones */
  price?: string | Record<string, string>;
  /** Descripci√≥n opcional del item */
  description?: string;
  /** Clave del icono (debe existir en ICONS) */
  icon?: string;
  /** Badge especial (ej: 'new') */
  badge?: string;
};

/** Estructura de una categor√≠a procesada */
interface ProcessedCategory {
  /** ID √∫nico para navegaci√≥n (slug) */
  id: string;
  /** Nombre visible de la categor√≠a */
  label: string;
  /** Ruta del icono o null si no tiene */
  iconPath: string | null;
  /** Descripci√≥n de la categor√≠a */
  description: string;
  /** Array de items de la categor√≠a */
  items: Item[];
}

/**
 * PROCESAMIENTO DE CATEGOR√çAS
 * ================================================================
 * Convierte el objeto del JSON en un array ordenado de categor√≠as,
 * procesando iconos y generando IDs √∫nicos.
 */
const categories: ProcessedCategory[] = ORDER
  .filter((label) => Object.prototype.hasOwnProperty.call(rawMenu, label))
  .map((label) => {
    const cfg = rawMenu[label] || {};
    const id = slugify(label);
    const iconKey = cfg.icon || null;
    const iconPath = iconKey && ICONS[iconKey] ? ICONS[iconKey] : null;
    
    return {
      id,
      label,
      iconPath,
      description: cfg.description || '',
      items: Array.isArray(cfg.items) ? cfg.items : [],
    };
  });

/**
 * UTILIDAD: Normalizador de items
 * ================================================================
 * Procesa un item del men√∫ para extraer y limpiar:
 * - Badges (nuevos, especiales)
 * - Iconos individuales
 * - Precios simples vs m√∫ltiples
 * - Nombres limpios (sin emojis)
 * 
 * @param it - Item sin procesar del JSON
 * @returns Item procesado y tipado
 */
interface ProcessedItem {
  name: string;
  description: string;
  priceSingle: string | null;
  priceMulti: [string, string][] | null;
  badge: string | null;
  iconPath: string | null;
}

function normalizeItem(it: Item): ProcessedItem {
  // Detecta badge 'new' por bandera o emoji
  const badge = it.badge === 'new' || 
    (typeof it.name === 'string' && it.name.includes('üÜï')) ? 'Nuevo' : null;
  
  // Limpia el nombre quitando emojis
  const cleanName = typeof it.name === 'string' ? 
    it.name.replace('üÜï', '').trim() : it.name;

  // Procesa icono del item (excluyendo el badge 'new')
  const itemIconKey = it.icon && it.icon !== 'new' ? it.icon : null;
  const itemIconPath = itemIconKey && ICONS[itemIconKey] ? ICONS[itemIconKey] : null;

  // Determina tipo de precio: simple (string) o m√∫ltiple (objeto)
  const isMultiPrice = it.price && 
    typeof it.price === 'object' && 
    !Array.isArray(it.price);
  
  const priceSingle = !isMultiPrice ? (it.price as string ?? null) : null;
  const priceMulti = isMultiPrice ? 
    Object.entries(it.price as Record<string, string>) : null;

  return {
    name: cleanName,
    description: it.description ?? '',
    priceSingle,
    priceMulti,
    badge,
    iconPath: itemIconPath
  };
}

/**
 * METADATOS SEO
 * ================================================================
 */
const pageTitle = 'Nuestra carta';
const pageDescription = 'Los mejores pollos asados, camperos, hamburguesas y m√°s en Torremolinos';
---

<BaseLayout title={pageTitle} description={pageDescription}>
  <main class="menu">
    
    <!-- 
      NAVEGACI√ìN STICKY DE CATEGOR√çAS
      ================================================================
      Barra horizontal scrolleable que se mantiene fija en la parte 
      superior. Cada chip es clickeable y muestra el icono de categor√≠a.
    -->
    <nav class="menu-nav sticky-header" aria-label="Categor√≠as de la carta">
      <ul>
        {categories.map((c) => (
          <li>
            <a href={`#${c.id}`}>
              {/* Icono de categor√≠a si existe */}
              {c.iconPath && (
                <span class="chip__icon" aria-hidden="true">
                  <img 
                    src={c.iconPath} 
                    alt="" 
                    loading="lazy" 
                    decoding="async" 
                  />
                </span>
              )}
              <span class="chip__label">{c.label}</span>
            </a>
          </li>
        ))}
      </ul>
    </nav>

    <!-- 
      SECCIONES DE CATEGOR√çAS
      ================================================================
      Cada secci√≥n corresponde a una categor√≠a del men√∫ y contiene
      sus items organizados.
    -->
    {categories.map((c) => (
      <section id={c.id} class="category-section">
        
        {/* T√≠tulo de secci√≥n con icono */}
        <h2>
          {c.iconPath && (
            <img 
              class="cat-icon" 
              src={c.iconPath} 
              alt="" 
              loading="lazy" 
              decoding="async" 
            />
          )}
          {c.label}
        </h2>

        {/* Descripci√≥n de categor√≠a si existe */}
        {c.description && (
          <p class="category-description">{c.description}</p>
        )}

        {/* Lista de items de la categor√≠a */}
        <ul>
          {c.items.map((raw) => {
            const it = normalizeItem(raw);
            return (
              <li class="menu-item">
                
                {/* Cabecera del item: nombre + precio simple */}
                <div class="item-header">
                  <strong>
                    {/* Icono del item si existe */}
                    {it.iconPath && (
                      <img 
                        class="item-icon" 
                        src={it.iconPath} 
                        alt="" 
                        loading="lazy" 
                        decoding="async" 
                      />
                    )}
                    {it.name}
                    {/* Badge si es nuevo u especial */}
                    {it.badge && (
                      <span class="badge badge--new">{it.badge}</span>
                    )}
                  </strong>

                  {/* Precio simple (solo si no tiene m√∫ltiples opciones) */}
                  {it.priceSingle && (
                    <span class="single-price">{it.priceSingle}</span>
                  )}
                </div>

                {/* Precios m√∫ltiples (ej: Media raci√≥n / Raci√≥n completa) */}
                {it.priceMulti && (
                  <ul class="multi-price">
                    {it.priceMulti.map(([portion, price]) => (
                      <li>
                        <span class="portion">{portion}</span>
                        <span class="price">{price}</span>
                      </li>
                    ))}
                  </ul>
                )}

                {/* Descripci√≥n del item si existe */}
                {it.description && (
                  <p class="item-description">{it.description}</p>
                )}
              </li>
            );
          })}
        </ul>
      </section>
    ))}
  </main>

<!-- 
  FUNCIONALIDAD JAVASCRIPT
  ================================================================
  Script que maneja:
  - Scroll suave entre secciones
  - Scrollspy (activaci√≥n autom√°tica de pesta√±as)
  - Navegaci√≥n horizontal autom√°tica de chips
  - C√°lculo din√°mico de alturas sticky
  - Intersection Observer para resaltado de secciones
-->
<script is:inline>
  /**
   * CONFIGURACI√ìN INICIAL
   * ================================================================
   */
  
  // Detecta preferencia de movimiento reducido
  const prefersNoMotion = matchMedia('(prefers-reduced-motion: reduce)').matches;

  // Selecciona elementos clave del DOM
  const siteHeader = document.querySelector('.site-header');
  const chipsNav   = document.querySelector('.menu-nav.sticky-header');
  const navLinks   = Array.from(document.querySelectorAll('.menu-nav a[href^="#"]'));
  const sections   = Array.from(document.querySelectorAll('.category-section[id]'));

  /**
   * GESTI√ìN DE ALTURAS DIN√ÅMICAS
   * ================================================================
   * Calcula y establece variables CSS para manejar el offset sticky
   * que cambia seg√∫n el tama√±o del header y la navegaci√≥n.
   */
  const setStickyVars = () => {
    const headerH = siteHeader?.offsetHeight ?? 0;
    const chipsH  = chipsNav?.offsetHeight ?? 0;
    
    // Establece variables CSS custom para uso en estilos
    document.documentElement.style.setProperty('--chips-h', `${chipsH}px`);
    document.documentElement.style.setProperty('--sticky-total', `${headerH + chipsH}px`);
    
    // Recalcula posiciones y actualiza estado
    computeSectionTops();
    rafUpdate();
  };

  // Actualiza alturas en eventos clave
  addEventListener('resize', setStickyVars);
  addEventListener('load', setStickyVars);
  setStickyVars(); // Ejecuci√≥n inicial

  /**
   * MAPEADO DE NAVEGACI√ìN
   * ================================================================
   * Crea un Map bidireccional entre IDs de secci√≥n y sus enlaces
   * para optimizar las b√∫squedas durante el scrollspy.
   */
  const linksMap = new Map();
  for (const a of navLinks) {
    const href = a.getAttribute('href') || '';
    const id = href.startsWith('#') ? href.slice(1) : '';
    if (id) linksMap.set(id, a);
  }

  /**
   * NAVEGACI√ìN POR CLIC
   * ================================================================
   * Maneja clics en los chips de navegaci√≥n con scroll suave
   * y actualizaci√≥n inmediata del estado activo.
   */
  navLinks.forEach((a) => {
    a.addEventListener('click', (e) => {
      const href = a.getAttribute('href') || '';
      const id = href.startsWith('#') ? href.slice(1) : '';
      const target = id ? document.getElementById(id) : null;
      if (!target) return;

      e.preventDefault();

      // Marca activo inmediatamente (UX m√°s responsive)
      setActive(id);

      // Scroll suave respetando preferencias de accesibilidad
      target.scrollIntoView({ 
        behavior: prefersNoMotion ? 'auto' : 'smooth', 
        block: 'start' 
      });
      
      // Actualiza URL sin recargar p√°gina
      history.replaceState(null, '', `#${id}`);
    });
  });

  /**
   * GESTI√ìN DE ESTADO ACTIVO
   * ================================================================
   * Actualiza visualmente qu√© pesta√±a est√° activa y hace scroll
   * autom√°tico de la navegaci√≥n horizontal si es necesario.
   */
  
  /**
   * Hace scroll del chip activo al centro de la vista
   * @param {Element} link - Enlace a centrar
   */
  const scrollChipIntoView = (link) => {
    if (!link) return;
    link.scrollIntoView({ 
      behavior: prefersNoMotion ? 'auto' : 'smooth', 
      block: 'nearest', 
      inline: 'center' 
    });
  };

  /**
   * Establece qu√© enlace est√° activo
   * @param {string} id - ID de la secci√≥n activa
   */
  const setActive = (id) => {
    let activeLink = null;
    
    linksMap.forEach((link, key) => {
      const isActive = key === id;
      
      // Toggle clase y atributo aria
      link.classList.toggle('active', isActive);
      link.toggleAttribute('aria-current', isActive);
      
      if (isActive) activeLink = link;
    });
    
    // Auto-scroll horizontal del chip activo
    scrollChipIntoView(activeLink);
  };

  /**
   * SCROLLSPY - DETECCI√ìN AUTOM√ÅTICA DE SECCI√ìN
   * ================================================================
   */
  
  /** Cache de posiciones de secciones para optimizar c√°lculos */
  let sectionTops = [];
  
  /**
   * Recalcula posiciones de todas las secciones
   * Se ejecuta en resize y cambios de layout
   */
  const computeSectionTops = () => {
    sectionTops = sections
      .map((s) => ({ 
        id: s.id, 
        top: s.getBoundingClientRect().top + scrollY 
      }))
      .sort((a, b) => a.top - b.top);
  };
  computeSectionTops(); // C√°lculo inicial

  /**
   * Determina qu√© secci√≥n est√° actualmente visible
   * teniendo en cuenta el offset del header sticky
   * @returns {string|null} ID de la secci√≥n activa
   */
  const getCurrentSectionId = () => {
    const stickyTotal = parseFloat(
      getComputedStyle(document.documentElement)
        .getPropertyValue('--sticky-total')
    ) || 0;
    
    const y = scrollY + stickyTotal + 1; // +1 para holgura
    let current = sectionTops[0]?.id || null;
    
    // Encuentra la √∫ltima secci√≥n que hemos pasado
    for (let i = 0; i < sectionTops.length; i++) {
      if (y >= sectionTops[i].top) {
        current = sectionTops[i].id;
      } else {
        break;
      }
    }
    
    return current;
  };

  /**
   * OPTIMIZACI√ìN CON RAF (RequestAnimationFrame)
   * ================================================================
   * Throttling para evitar ejecutar scrollspy en cada frame
   */
  let ticking = false;
  
  const rafUpdate = () => {
    if (ticking) return;
    ticking = true;
    
    requestAnimationFrame(() => {
      const id = getCurrentSectionId();
      if (id) setActive(id);
      ticking = false;
    });
  };

  /**
   * EVENT LISTENERS PRINCIPALES
   * ================================================================
   */
  
  // Scrollspy en scroll
  document.addEventListener('scroll', rafUpdate, { passive: true });
  
  // Rec√°lculo en cambios de viewport
  addEventListener('resize', () => { 
    computeSectionTops(); 
    rafUpdate(); 
  });
  
  // Activaci√≥n inicial
  addEventListener('load', () => { 
    computeSectionTops(); 
    rafUpdate(); 
  });
  
  rafUpdate(); // Primera ejecuci√≥n

  /**
   * INTERSECTION OBSERVER - RESALTADO VISUAL
   * ================================================================
   * A√±ade clase visual a secciones que est√°n en viewport
   * para efectos de resaltado (opcional, mejora UX)
   */
  const io = new IntersectionObserver((entries) => {
    entries.forEach((e) => {
      e.target.classList.toggle('active-section', e.isIntersecting);
    });
  }, {
    root: null,
    // Offset superior: quita header+chips, inferior: 50% para estabilidad
    rootMargin: `calc(-1 * var(--sticky-total, 0px)) 0px -50% 0px`,
    threshold: 0.2,
  });

  // Observa todas las secciones
  sections.forEach((s) => io.observe(s));
</script>

</BaseLayout>